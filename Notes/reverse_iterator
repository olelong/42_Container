#include <iostream>
#include <vector>

using namespace std;

voir l'iterateur comme un pointeur car il stocke aussi une adresse.

constructor (iterator it ou reverse_iterator rev_it)
    this->p = &(*it); // recuperer le p de l'iterateur malgre le fait qu il soit prive


int main()
{
    vector<float> victor(4, 12.5f);
    victor.push_back(6.7f);
			    
    reverse_iterator<vector<float>::iterator> serge = victor.rbegin();
			    
	// Test pour savoir si il y a un decalage entre begin() et rend() et l'inverse
	//				en effet, rend() pointe sur begin() - 1
    std::cout << victor.data() + victor.size() << std::endl; // on affiche la end() de victor
    std::cout << &(*victor.end()) << std::endl;
    std::cout << &(*victor.rbegin()) << std::endl;
    std::cout << &(*victor.begin()) << std::endl;
	std::cout << &(*victor.rend()) << std::endl;
	

	//test iterator basic
	for (vector<float>::reverse_iterator rit = victor.rbegin(); rit != victor.rend(); rit++)
		std::cout << *rit << std::endl;

	//operator +
	vector<float>::reverse_iterator nelson = victor.cbegin(), wael;
	wael = nelson + 2; // operator+
	//ret  *this->p n
																			    
    return 0;
	}

operator+
    reverse_iterator wael //creer un reverse iterator que l'on retournera a la fin
    wael.p  = this->p + 2; // ajouter difference_type n a this->p
    return wael; 

// rbegin = end - 1 (pour l'adresse)
// rend = begin - 1 (pour l'adresse)

int main()
{
	std::vector<int> vec(5, 12);
	std::vector<int>::iterator it = vec.begin();
	std::vector<int>::iterator it2 = vec.end();

	std::vector<int>::reverse_iterator rev;
	rev = &(*it2);
}


Certaines explications de la documentation sont liees a l'utilisation de la fonction ou du conteneur
et donc n'es pas a prendre en compte. La doc est destinee aux utilisateurs.


! A lire :  LEXICOGRAPHICAL_COMPARE 

std::lexicographical_compare : 

Lexicographical less-than comparison
Returns true if the range [first1,last1) compares lexicographically less than the range [first2,last2).

A lexicographical comparison is the kind of comparison generally used to sort words alphabetically in dictionaries; It involves comparing sequentially the elements that have the same position in both ranges against each other until one element is not equivalent to the other. The result of comparing these first non-matching elements is the result of the lexicographical comparison.

If both sequences compare equal until one of them ends, the shorter sequence is lexicographically less than the longer one.

The elements are compared using operator< for the first version, and comp for the second. Two elements, a and b are considered equivalent if (!(a<b) && !(b<a)) or if (!comp(a,b) && !comp(b,a)).

template <class InputIterator1, class InputIterator2>
  bool lexicographical_compare (InputIterator1 first1, InputIterator1 last1,
                                InputIterator2 first2, InputIterator2 last2)
{
  while (first1!=last1)
  {
    if (first2==last2 || *first2<*first1) return false;
    else if (*first1<*first2) return true;
    ++first1; ++first2;
  }
  return (first2!=last2);
}

Relationnal operators : lecture des tableau de la doc
operator on
reverse iterators	equivalent used on
					base iterators
	==						==
	!=						!=
	< 						>
	<=						>=
	> 						<
	>=						<=

exemple operator<(lhs, rhs) {if (lhs > rhs) return false; return true;}


Faire operateurs overload manquant comme =
Utiliser que this->it, plus besoin de p
